<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<title>sqlite</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>
<body>

<div id="Sqlite 使用技巧拾零"><h1 id="Sqlite 使用技巧拾零">Sqlite 使用技巧拾零</h1></div>

<div id="Sqlite 使用技巧拾零-时间格式"><h3 id="时间格式">时间格式</h3></div>

<pre sql>
select datetime('now', 'localtime');

CREATE TABLE whatever (
     ...
     ts DATETIME DEFAULT (datetime('now', 'localtime')),
     ...
);
</pre>

<p>
参考 <a href="https://stackoverflow.com/questions/381371/sqlite-current-timestamp-is-in-gmt-not-the-timezone-of-the-machine">https://stackoverflow.com/questions/381371/sqlite-current-timestamp-is-in-gmt-not-the-timezone-of-the-machine</a>  
</p>


<p>
签到逻辑例子
</p>
<pre sql>
create table user (
  id integer primary key,
  name varchar(64) not null,
  ts datetime default (datetime('now', 'localtime'))
);

create table checkin (
  id integer primary key,
  user integer not null references "user" ("id"),
  date date not null default (date('now', 'localtime')),
  ts datetime default (datetime('now', 'localtime')),
  unique (user, date)
);

-- create index idx_checkin__user on checkin (user);

insert into user (name) values('q1');
insert into user (name) values('q2');
insert into user (name) values('q3');

insert into checkin (user) values(1);
insert into checkin (user) values(1);
insert into checkin (user) values(2);
insert into checkin (user) values(3);

</pre>

<p>
对应 ponyorm
</p>
<pre python>
class User(Entity):
    name = Required(str, 64)
    ts = Optional(datetime)
    checkins = Set(lambda: Checkin)

class Checkin(Entity):
    user = Required(lambda: User)
    date = Required(date, sql_default="(date('now', 'localtime'))")
    ts = Optional(datetime)
    composite_key(user, date)
</pre>


<div id="Sqlite 使用技巧拾零-高速合并数据"><h3 id="高速合并数据">高速合并数据</h3></div>

<p>
两个表：<code>main</code>, <code>patch</code>，结构一样，main 数据量很大，patch 数据量一般，现在需要合并 patch 的数据至 main，
对已存在的老数据做覆盖操作，对不存在的数据做新增操作，尽量不要做无用功，尽可能地收集到更新结果如修改数和新增数。
</p>

<pre sql>
-- main 是老数据，把 patch 作为补丁更新至 main , 参考下面
-- 执行速度只和 patch 的数据量有关，和目标 main 数据量关系不大（有索引），patch 数据量有 100W 时，2 秒搞定

select 'edit';
replace into main (k, v) 
select patch.k, patch.v from patch inner join main on patch.k = main.k where patch.v != main.v;  -- update exists
select changes();

select 'new';
insert into main (k, v) 
select patch.k, patch.v from patch left join main on patch.k = main.k where main.v is null;  -- find new
select changes();
</pre>


<div id="Sqlite 使用技巧拾零-OperationalError: database is locked"><h3 id="OperationalError: database is locked">OperationalError: database is locked</h3></div>

<p>
一次写入或修改数据太多，在这过程中，别的进程读数据会发生这种错误，暂时没有深入研究。
目前的解决方案是，一次性修改数据超过 10000，就做一次 commit，这样，无论是在什么阶段，都不会阻塞其它进程的读操作。
</p>


<div id="Sqlite 使用技巧拾零-其它参考学习"><h3 id="其它参考学习">其它参考学习</h3></div>

<p>
<a href="http://souptonuts.sourceforge.net/readme_sqlite_tutorial.html">http://souptonuts.sourceforge.net/readme_sqlite_tutorial.html</a>
</p>

</body>
</html>
